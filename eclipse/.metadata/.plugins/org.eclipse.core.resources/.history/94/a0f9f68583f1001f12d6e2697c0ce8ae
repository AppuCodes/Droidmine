package roger.pathfind.main.walk;

import java.util.List;

import org.lwjgl.input.Keyboard;

import net.minecraft.client.ClientEngine;
import net.minecraft.client.Minecraft;
import net.minecraft.client.options.KeyBinding;
import net.minecraft.entity.Entity;
import net.minecraft.util.*;
import roger.pathfind.main.LookManager;
import roger.pathfind.main.astar.AStarNode;
import roger.pathfind.main.astar.AStarPathFinder;
import roger.pathfind.main.path.PathElm;
import roger.pathfind.main.path.impl.*;
import roger.pathfind.main.processor.ProcessorManager;
import roger.pathfind.main.walk.target.WalkTarget;
import roger.pathfind.main.walk.target.impl.*;

public class Walker {
    private boolean isActive;

    List<PathElm> path;
    WalkTarget currentTarget;
    ClientEngine mc;

    public void walk(BlockPos start, BlockPos end, int nodeCount, ClientEngine mc) {
        this.mc = mc;
        isActive = true;

        List<AStarNode> nodes = AStarPathFinder.compute(start, end, nodeCount);
        path = ProcessorManager.process(nodes, mc.world);

        if(path.size() == 0) {
            isActive = false;
            currentTarget = null;
            return;
        }

        currentTarget = null;
    }

    public void tick()
    {
        if(!isActive)
            return;

        if(currentTarget == null)
            currentTarget = getCurrentTarget(path.get(0));

        WalkTarget playerOnTarget;
        if(!((playerOnTarget = onTarget()) == null))
            currentTarget = playerOnTarget;

        // while, so we don't skip ticks
        while (tick(currentTarget)) {
            // removes it
            path.remove(0);

            if(path.isEmpty()) {
                isActive = false;
                currentTarget = null;
                KeyBinding.setKeyBindState(Keyboard.KEY_W, false);
                KeyBinding.setKeyBindState(Keyboard.KEY_A, false);
                KeyBinding.setKeyBindState(Keyboard.KEY_D, false);
                KeyBinding.setKeyBindState(Keyboard.KEY_S, false);
                return;
            }

            currentTarget = getCurrentTarget(path.get(0));
        }

        KeyBinding.setKeyBindState(Keyboard.KEY_LCONTROL, true);
        Tuple<Double, Double> angles = getAngles(mc.player, currentTarget.getCurrentTarget());
        LookManager.getInstance().setTarget(angles.getFirst().floatValue(), currentTarget instanceof JumpTarget ? -10 : 10);

        pressKeys(angles.getFirst().floatValue());
    }

    public static Tuple<Double, Double> getAngles(Entity player, BlockPos pos) {
        return getAngles(player.getPositionVector().addVector(0, player.getEyeHeight(), 0), new Vec3(pos).addVector(0.5f, 0.5f, 0.5f), player.rotationYaw);
    }

    public static Tuple<Double, Double> getAngles(Vec3 origin, Vec3 point, double currentYaw) {
        double dx = origin.xCoord - point.xCoord;
        double dy = origin.yCoord - point.yCoord;
        double dz = origin.zCoord - point.zCoord;
        double dist = Math.sqrt(dx*dx + dz*dz);

        if(dist == 0)
            return new Tuple<>(0.0, 0.0);

        double pitch = 90 - Math.toDegrees(Math.atan(dist/Math.abs(dy)));
        if (dy < 0)
            pitch = -pitch;

        double angle =  Math.toDegrees(Math.atan(Math.abs(dx/dz)));
        double yaw;
        if(dx > 0 && dz < 0)
            yaw = angle;
        else if(dx > 0 && dz > 0)
            yaw = 180 - angle;
        else if (dx < 0 && dz > 0)
            yaw = 180 + angle;
        else
            yaw = 360 - angle;

        double diff = yaw - currentYaw;

        while (diff > 180) {
            yaw -= 360;
            diff = yaw - currentYaw;
        }

        while (diff < -180) {
            yaw += 360;
            diff = yaw - currentYaw;
        }

        return new Tuple<>(yaw, pitch);
    }

    private void pressKeys(double targetYaw, Entity player) {
        double difference = targetYaw - player.rotationYaw;
        KeyBinding.setKeyBindState(Keyboard.KEY_W, false);
        KeyBinding.setKeyBindState(Keyboard.KEY_A, false);
        KeyBinding.setKeyBindState(Keyboard.KEY_S, false);
        KeyBinding.setKeyBindState(Keyboard.KEY_D, false);

        if(22.5 > difference && difference > -22.5) {   // Forwards

            KeyBinding.setKeyBindState(Keyboard.KEY_W, true);
        } else if(-22.5 > difference && difference > -67.5) {   // Forwards+Right

            KeyBinding.setKeyBindState(Keyboard.KEY_W, true);
            KeyBinding.setKeyBindState(Keyboard.KEY_A, true);
        } else if(-67.5 > difference && difference > -112.5) { // Right

            KeyBinding.setKeyBindState(Keyboard.KEY_A, true);
        } else if(-112.5 > difference && difference > -157.5) { // Backwards + Right

            KeyBinding.setKeyBindState(Keyboard.KEY_A, true);
            KeyBinding.setKeyBindState(Keyboard.KEY_S, true);
        } else if((-157.5 > difference && difference > -180) || (180 > difference && difference > 157.5)) { // Backwards

            KeyBinding.setKeyBindState(Keyboard.KEY_S, true);
        } else if(67.5 > difference && difference > 22.5) { // Forwards + Left

            KeyBinding.setKeyBindState(Keyboard.KEY_W, true);
            KeyBinding.setKeyBindState(Keyboard.KEY_D, true);

        } else if(112.5 > difference && difference > 67.5) { // Left

            KeyBinding.setKeyBindState(Keyboard.KEY_D, true);
        } else if(157.5 > difference && difference > 112.5) {  // Backwards+Left

            KeyBinding.setKeyBindState(Keyboard.KEY_S, true);
            KeyBinding.setKeyBindState(Keyboard.KEY_D, true);
        }
    }

    // This checks if the player is on any nodes further in the queue, which means the player, due to probably high speed, has skipped some. Then
    // this removes the nodes behind it and sets it as the current target.
    private WalkTarget onTarget() {
        for(int i = 0 ; i < path.size() ; i++) {
            PathElm elm = path.get(i);

            if(elm.playerOn(Minecraft.getMinecraft().thePlayer.getPositionVector())) {
                System.out.println("Returned true: " + elm);

                if(elm == currentTarget.getElm())
                    return null;



                // Get the next one if the player is on it
                // if its travel vector, we don't get the next one, cos we need to go to the dest.
                // if its jump, we don't get the next one, cos we need to jump.
                if(path.size() > i + 1 && !(elm instanceof TravelVector) && !(elm instanceof JumpNode)) {
                    System.out.println("E");
                    path.subList(0, i + 1).clear();
                } else {
                    path.subList(0, i).clear();
                }

                // cutting off might end jump target so stop jumping
                KeyBinding.setKeyBindState(Keyboard.KEY_SPACE, false);


                return getCurrentTarget(path.get(0));
            }
        }

        return null;
    }

    // The return value of this is if the node has been satisfied, and the next one should be polled.
    private boolean tick(WalkTarget current) {

        // We should improve the predicted motion calculation. Right now it's based on the estimate that the motion will last for 12 ticks, but this is different across speeds.
        Vec3 offset = new Vec3(Minecraft.getMinecraft().thePlayer.motionX, 0, Minecraft.getMinecraft().thePlayer.motionZ);
        Vec3 temp = offset;
        offset.add(temp);

        for(int i = 0 ; i < 12 ; i++) {

            // 0.54600006f is how much the motion stops after every tick after not moving.
            offset = offset.add((temp = Util.vecMultiply(temp, 0.54600006f)));
        }

        return current.tick(offset, Minecraft.getMinecraft().thePlayer.getPositionVector());
    }

    private WalkTarget getCurrentTarget(PathElm elm) {
        if(elm instanceof FallNode)
            return new FallTarget((FallNode) elm);
        if(elm instanceof TravelNode)
            return new TravelTarget((TravelNode) elm);
        if(elm instanceof TravelVector)
            return new TravelVectorTarget((TravelVector) elm);
        if(elm instanceof JumpNode) {
            if(path.size() > 1)
                return new JumpTarget((JumpNode) elm, getCurrentTarget(path.get(1)));
            return new JumpTarget((JumpNode) elm, null);
        }
        System.out.println("Wrong walk target");
        return null;
    }
    public boolean isActive() {
        return isActive;
    }

    public static Walker getInstance() {
        return instance;
    }
}
